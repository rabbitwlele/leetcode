# Palindrome Partitioning III
[分隔回文串](https://leetcode.com/problems/palindrome-partitioning-iii/)
> 给你一个字符串，将该字符串分成k份，可以将任意一个字符串替换，保证每一份都是回文串。求最小的替换次数

## 分析
这个题目不算困难，DP的味道非常明显。

设字符串为s

dp[i][k]代表 s[0,i)，分隔为k份，最小的替换次数
```go
for m := 0; m < i; m++ {
	dp[i][k] = min(dp[i][k], dp[m][k-1]+ 替换次数(s[m:j]))
}
```
接下来就是求**替换次数**

这个就很简单了，就是左右比较不一样的字符就可以了

## 总结
这道题目本身没有太大的难度，主要是在字符串的边界条件上。

因为本来字符串就是左闭右开的，所以我们延续了这种选择。dp[i][k]并不包含i。

这么做有个好处，就是所有的状态都是从dp[0][0]这个状态衍生。

对于我个人来说，这种边界条件的处理并不是一个很简单的事情。以后类似的问题可以延续这个思路。
